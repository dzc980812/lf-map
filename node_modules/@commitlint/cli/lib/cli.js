#!/usr/bin/env node
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/stable");

require("regenerator-runtime/runtime");

var _load = _interopRequireDefault(require("@commitlint/load"));

var _lint = _interopRequireDefault(require("@commitlint/lint"));

var _read = _interopRequireDefault(require("@commitlint/read"));

var _meow = _interopRequireDefault(require("meow"));

var _lodash = require("lodash");

var _getStdin = _interopRequireDefault(require("get-stdin"));

var _resolveFrom = _interopRequireDefault(require("resolve-from"));

var _resolveGlobal = _interopRequireDefault(require("resolve-global"));

var _help = _interopRequireDefault(require("./help"));

const pkg = require('../package');

const flags = {
  color: {
    alias: 'c',
    default: true,
    description: 'toggle colored output',
    type: 'boolean'
  },
  config: {
    alias: 'g',
    default: null,
    description: 'path to the config file',
    type: 'string'
  },
  cwd: {
    alias: 'd',
    default: process.cwd(),
    description: 'directory to execute in',
    type: 'string'
  },
  edit: {
    alias: 'e',
    default: false,
    description: 'read last commit message from the specified file or fallbacks to ./.git/COMMIT_EDITMSG',
    type: 'string'
  },
  env: {
    alias: 'E',
    default: null,
    description: 'check message in the file at path given by environment variable value',
    type: 'string'
  },
  extends: {
    alias: 'x',
    description: 'array of shareable configurations to extend',
    type: 'string'
  },
  help: {
    alias: 'h',
    type: 'boolean',
    description: 'display this help message'
  },
  'help-url': {
    alias: 'H',
    type: 'string',
    description: 'helpurl in error message'
  },
  from: {
    alias: 'f',
    default: null,
    description: 'lower end of the commit range to lint; applies if edit=false',
    type: 'string'
  },
  format: {
    alias: 'o',
    default: null,
    description: 'output format of the results',
    type: 'string'
  },
  'parser-preset': {
    alias: 'p',
    description: 'configuration preset to use for conventional-commits-parser',
    type: 'string'
  },
  quiet: {
    alias: 'q',
    default: false,
    description: 'toggle console output',
    type: 'boolean'
  },
  to: {
    alias: 't',
    default: null,
    description: 'upper end of the commit range to lint; applies if edit=false',
    type: 'string'
  },
  version: {
    alias: 'v',
    type: 'boolean',
    description: 'display version information'
  },
  verbose: {
    alias: 'V',
    type: 'boolean',
    description: 'enable verbose output for reports without problems'
  }
};
const cli = (0, _meow.default)({
  description: `${pkg.name}@${pkg.version} - ${pkg.description}`,
  flags,
  help: `[input] reads from stdin if --edit, --env, --from and --to are omitted\n${(0, _help.default)(flags)}`,

  unknown(arg) {
    throw new Error(`unknown flags: ${arg}`);
  }

});
main(cli).catch(err => setTimeout(() => {
  if (err.type === pkg.name) {
    process.exit(1);
  }

  throw err;
}));

function main(options) {
  return new Promise(function ($return, $error) {
    let raw, flags, fromStdin, range, input, messages, loadOpts, loaded, parserOpts, opts, format, results, report, output;
    raw = options.input;
    flags = normalizeFlags(options.flags);
    fromStdin = checkFromStdin(raw, flags);
    range = (0, _lodash.pick)(flags, 'edit', 'from', 'to');
    return Promise.resolve(fromStdin ? (0, _getStdin.default)() : (0, _read.default)(range, {
      cwd: flags.cwd
    })).then(function ($await_1) {
      try {
        input = $await_1;
        messages = (Array.isArray(input) ? input : [input]).filter(message => typeof message === 'string').filter(message => message.trim() !== '').filter(Boolean);

        if (messages.length === 0 && !checkFromRepository(flags)) {
          let err;
          err = new Error('[input] is required: supply via stdin, or --env or --edit or --from and --to');
          err.type = pkg.name;
          console.log(`${cli.help}\n`);
          console.log(err.message);
          return $error(err);
        }

        loadOpts = {
          cwd: flags.cwd,
          file: flags.config
        };
        return Promise.resolve((0, _load.default)(getSeed(flags), loadOpts)).then(function ($await_2) {
          try {
            loaded = $await_2;
            parserOpts = selectParserOpts(loaded.parserPreset);
            opts = {
              parserOpts: {},
              plugins: {},
              ignores: [],
              defaultIgnores: true
            };

            if (parserOpts) {
              opts.parserOpts = parserOpts;
            }

            if (loaded.plugins) {
              opts.plugins = loaded.plugins;
            }

            if (loaded.ignores) {
              opts.ignores = loaded.ignores;
            }

            if (loaded.defaultIgnores === false) {
              opts.defaultIgnores = false;
            }

            format = loadFormatter(loaded, flags);

            // Strip comments if reading from `.git/COMMIT_EDIT_MSG`
            if (range.edit) {
              opts.parserOpts.commentChar = '#';
            }

            return Promise.resolve(Promise.all(messages.map(message => (0, _lint.default)(message, loaded.rules, opts)))).then(function ($await_3) {
              try {
                results = $await_3;

                if (Object.keys(loaded.rules).length === 0) {
                  let input = '';

                  if (results.length !== 0) {
                    let originalInput;
                    originalInput = results[0].input;
                    input = originalInput;
                  }

                  results.splice(0, results.length, {
                    valid: false,
                    errors: [{
                      level: 2,
                      valid: false,
                      name: 'empty-rules',
                      message: ['Please add rules to your `commitlint.config.js`', '    - Getting started guide: https://git.io/fhHij', '    - Example config: https://git.io/fhHip'].join('\n')
                    }],
                    warnings: [],
                    input
                  });
                }

                report = results.reduce((info, result) => {
                  info.valid = result.valid ? info.valid : false;
                  info.errorCount += result.errors.length;
                  info.warningCount += result.warnings.length;
                  info.results.push(result);
                  return info;
                }, {
                  valid: true,
                  errorCount: 0,
                  warningCount: 0,
                  results: []
                });
                output = format(report, {
                  color: flags.color,
                  verbose: flags.verbose,
                  helpUrl: flags.helpUrl ? flags.helpUrl.trim() : 'https://github.com/conventional-changelog/commitlint/#what-is-commitlint'
                });

                if (!flags.quiet && output !== '') {
                  console.log(output);
                }

                if (!report.valid) {
                  let err;
                  err = new Error(output);
                  err.type = pkg.name;
                  return $error(err);
                }

                return $return();
              } catch ($boundEx) {
                return $error($boundEx);
              }
            }, $error);
          } catch ($boundEx) {
            return $error($boundEx);
          }
        }, $error);
      } catch ($boundEx) {
        return $error($boundEx);
      }
    }, $error);
  });
}

function checkFromStdin(input, flags) {
  return input.length === 0 && !checkFromRepository(flags);
}

function checkFromRepository(flags) {
  return checkFromHistory(flags) || checkFromEdit(flags);
}

function checkFromEdit(flags) {
  return Boolean(flags.edit) || flags.env;
}

function checkFromHistory(flags) {
  return typeof flags.from === 'string' || typeof flags.to === 'string';
}

function normalizeFlags(flags) {
  const edit = getEditValue(flags);
  return (0, _lodash.merge)({}, flags, {
    edit,
    e: edit
  });
}

function getEditValue(flags) {
  if (flags.env) {
    if (!(flags.env in process.env)) {
      throw new Error(`Recieved '${flags.env}' as value for -E | --env, but environment variable '${flags.env}' is not available globally`);
    }

    return process.env[flags.env];
  }

  const edit = flags.edit; // If the edit flag is set but empty (i.e '-e') we default
  // to .git/COMMIT_EDITMSG

  if (edit === '') {
    return true;
  }

  if (typeof edit === 'boolean') {
    return edit;
  } // The recommended method to specify -e with husky was `commitlint -e $HUSKY_GIT_PARAMS`
  // This does not work properly with win32 systems, where env variable declarations
  // use a different syntax
  // See https://github.com/conventional-changelog/commitlint/issues/103 for details
  // This has been superceded by the `-E GIT_PARAMS` / `-E HUSKY_GIT_PARAMS`


  const isGitParams = edit === '$GIT_PARAMS' || edit === '%GIT_PARAMS%';
  const isHuskyParams = edit === '$HUSKY_GIT_PARAMS' || edit === '%HUSKY_GIT_PARAMS%';

  if (isGitParams || isHuskyParams) {
    console.warn(`Using environment variable syntax (${edit}) in -e |\
--edit is deprecated. Use '{-E|--env} HUSKY_GIT_PARAMS instead'`);

    if (isGitParams && 'GIT_PARAMS' in process.env) {
      return process.env.GIT_PARAMS;
    }

    if ('HUSKY_GIT_PARAMS' in process.env) {
      return process.env.HUSKY_GIT_PARAMS;
    }

    throw new Error(`Received ${edit} as value for -e | --edit, but GIT_PARAMS or HUSKY_GIT_PARAMS are not available globally.`);
  }

  return edit;
}

function getSeed(seed) {
  const e = Array.isArray(seed.extends) ? seed.extends : [seed.extends];
  const n = e.filter(i => typeof i === 'string');
  return n.length > 0 ? {
    extends: n,
    parserPreset: seed.parserPreset
  } : {
    parserPreset: seed.parserPreset
  };
}

function selectParserOpts(parserPreset) {
  if (typeof parserPreset !== 'object') {
    return undefined;
  }

  if (typeof parserPreset.parserOpts !== 'object') {
    return undefined;
  }

  return parserPreset.parserOpts;
}

function loadFormatter(config, flags) {
  const moduleName = flags.format || config.formatter || '@commitlint/format';

  const modulePath = _resolveFrom.default.silent(__dirname, moduleName) || _resolveFrom.default.silent(flags.cwd, moduleName) || _resolveGlobal.default.silent(moduleName);

  if (modulePath) {
    const moduleInstance = require(modulePath);

    if ((0, _lodash.isFunction)(moduleInstance.default)) {
      return moduleInstance.default;
    }

    return moduleInstance;
  }

  throw new Error(`Using format ${moduleName}, but cannot find the module.`);
} // Catch unhandled rejections globally


process.on('unhandledRejection', (reason, promise) => {
  console.log('Unhandled Rejection at: Promise ', promise, ' reason: ', reason);
  throw reason;
});
//# sourceMappingURL=cli.js.map